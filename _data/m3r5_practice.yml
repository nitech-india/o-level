sets:
- duration_minutes: 45
  id: 1
  name: Practice Set 1 - Introduction to Programming, Algorithm and Flowcharts (20
    marks)
  questions:
  - answer: B
    choices:
      A: To draw pictures
      B: To provide step-by-step instructions to solve a problem
      C: To write poetry
      D: To compile code
      E: All of the above
    explanation: An algorithm provides step-by-step instructions to solve a problem.
    text: What is the primary purpose of an algorithm?
    topic: Introduction to Programming, Algorithm and Flowcharts to solve problems
  - answer: C
    choices:
      A: Unambiguous
      B: Finite
      C: Infinite loops
      D: Well-defined inputs and outputs
      E: All of the above
    explanation: A good algorithm should not have infinite loops.
    text: Which of the following is not a characteristic of a good algorithm?
  - answer: C
    choices:
      A: Rectangle
      B: Oval
      C: Diamond
      D: Circle
      E: All of the above
    explanation: A diamond symbol is used for decision-making in flowcharts.
    text: What symbol is used for decision-making in a flowchart?
  - answer: D
    choices:
      A: Start or End
      B: Input/Output
      C: Decision
      D: Process or Operation
      E: All of the above
    explanation: A rectangle represents a process or operation in a flowchart.
    text: What does a rectangle represent in a flowchart?
  - answer: A
    choices:
      A: Oval
      B: Diamond
      C: Parallelogram
      D: Square
      E: All of the above
    explanation: An oval shape is used for the start or end (terminator) in a flowchart.
    text: Which shape represents the start or end of a flowchart?
  - answer: B
    choices:
      A: Show processing steps
      B: Indicate flow of control
      C: Indicate data types
      D: Connect to databases
      E: All of the above
    explanation: Arrows indicate the flow of control or direction of process in a
      flowchart.
    text: 'In flowcharts, arrows are used to:'
  - answer: C
    choices:
      A: They speed up typing
      B: They make code look fancy
      C: They visually represent the logic and flow of an algorithm
      D: They replace code entirely
      E: All of the above
    explanation: Flowcharts help programmers visualize the logic and flow of an algorithm,
      making it easier to understand and debug.
    text: What is the main advantage of using flowcharts in programming?
  - answer: C
    choices:
      A: A programming language
      B: A hardware device
      C: A step-by-step procedure to solve a problem
      D: A type of loop
      E: All of the above
    explanation: An algorithm is a step-by-step procedure to solve a problem.
    text: What is an algorithm?
  - answer: A
    choices:
      A: Input/Output
      B: Decision
      C: Loop
      D: Process
      E: All of the above
    explanation: A parallelogram represents input or output operations in a flowchart.
    text: 'In a flowchart, a parallelogram represents:'
  - answer: C
    choices:
      A: Circle
      B: Rectangle
      C: Oval
      D: Hexagon
      E: All of the above
    explanation: An oval denotes the start or end (terminator) in a flowchart.
    text: What symbol in a flowchart denotes the start or end?
  - answer: C
    choices:
      A: Infinite loop
      B: Ambiguous steps
      C: Finite steps
      D: Undefined inputs
      E: All of the above
    explanation: A good algorithm has a finite number of steps.
    text: Which of the following is a property of a good algorithm?
  - answer: D
    choices:
      A: Connect components
      B: Represent output
      C: Store data
      D: Show direction of flow
      E: All of the above
    explanation: Arrows show the direction of flow in a flowchart.
    text: 'In flowcharts, arrows are used to:'
  - answer: B
    choices:
      A: Input/Output
      B: Process
      C: Loop
      D: Terminator
      E: All of the above
    explanation: A rectangle represents a process or operation in a flowchart.
    text: 'A rectangle in a flowchart represents:'
  - answer: B
    choices:
      A: Write the code
      B: Identify the problem
      C: Debug the solution
      D: Draw a flowchart
      E: All of the above
    explanation: The first step in designing an algorithm is to identify the problem
      to be solved.
    text: What is the first step in designing an algorithm?
  - answer: B
    choices:
      A: Iterative
      B: Top-down
      C: Bottom-up
      D: Randomized
      E: All of the above
    explanation: Recursive functions typically use a top-down approach, breaking problems
      into subproblems.
    text: Which algorithmic approach does a recursive function represent?
  - answer: A
    choices:
      A: Solve recursively and merge
      B: Brute force all solutions
      C: Use dynamic memory
      D: Avoid recursion
      E: All of the above
    explanation: Divide and Conquer solves problems by dividing them into subproblems,
      solving recursively, and merging results.
    text: What is the main idea behind the Divide and Conquer algorithm?
  - answer: B
    choices:
      A: Bubble Sort
      B: Merge Sort
      C: Insertion Sort
      D: Selection Sort
      E: All of the above
    explanation: Merge Sort divides the array into subarrays, sorts them, and merges
      the results.
    text: In which algorithm is the array divided into smaller subarrays and sorted
      individually?
  - answer: C
    choices:
      A: Bubble Sort
      B: Merge Sort
      C: Quick Sort
      D: Selection Sort
      E: All of the above
    explanation: Quick Sort generally has the best average-case performance among
      common sorting algorithms.
    text: Which sorting algorithm has the best average-case performance?
  - answer: B
    choices:
      A: Queue
      B: Stack
      C: Heap
      D: Set
      E: All of the above
    explanation: DFS uses a stack data structure, either explicitly or via recursion.
    text: Which data structure is used in Depth-First Search (DFS)?
  - answer: B
    choices:
      A: Storing data on disk
      B: Caching results of expensive function calls
      C: Encrypting variables
      D: Loop unrolling
      E: All of the above
    explanation: Memoization is caching results of expensive function calls to avoid
      redundant computation.
    text: What is memoization?
  - answer: E
    choices:
      A: Unambiguous steps
      B: Finite number of steps
      C: Well-defined inputs and outputs
      D: Efficient in terms of time and space
      E: All of the above
    explanation: A good algorithm is unambiguous, finite, well-defined, and efficient.
    text: Which of the following are characteristics of a good algorithm?
    topic: Algorithm
    type: multiple
  - answer: E
    choices:
      A: Oval for Start/End
      B: Rectangle for Process
      C: Diamond for Decision
      D: Parallelogram for Input/Output
      E: All of the above
    explanation: All are standard flowchart symbols.
    text: Which of the following are valid flowchart symbols?
    topic: Flowcharts
    type: multiple
  - answer: E
    choices:
      A: Definiteness
      B: Input
      C: Output
      D: Finiteness
      E: All of the above
    explanation: Definiteness, input, output, and finiteness are all properties of
      algorithms.
    text: Which of the following are valid properties of algorithms?
    topic: Algorithm
    type: multiple
  - answer:
    - A
    - B
    - C
    choices:
      A: Visualizing program logic
      B: Debugging algorithms
      C: Documenting code structure
      D: Replacing source code
      E: All of the above
    explanation: Flowcharts are for visualization, debugging, and documentation, not
      for replacing code.
    text: Which of the following are valid uses of flowcharts in programming?
    topic: Flowcharts
    type: multiple
  - answer:
    - A
    - B
    - C
    choices:
      A: Divide and Conquer
      B: Greedy Method
      C: Dynamic Programming
      D: Random Guessing
      E: All of the above
    explanation: Divide and conquer, greedy, and dynamic programming are valid; random
      guessing is not.
    text: Which of the following are valid algorithmic problem-solving strategies?
    topic: Algorithm
    type: multiple
  - answer: E
    choices:
      A: Understanding the problem
      B: Designing an algorithm
      C: Implementing the solution
      D: Testing and debugging
      E: All of the above
    explanation: All are steps in problem-solving.
    text: Which of the following are valid steps in the problem-solving process?
    topic: Problem Solving
    type: multiple
  - answer: E
    choices:
      A: Sequence
      B: Selection
      C: Iteration
      D: Recursion
      E: All of the above
    explanation: Sequence, selection, iteration, and recursion are all control structures.
    text: Which of the following are valid types of control structures in algorithms?
    topic: Algorithm
    type: multiple
  - answer:
    - A
    - B
    - D
    choices:
      A: Base case
      B: Recursive case
      C: Infinite loop
      D: Reduction step
      E: All of the above
    explanation: Base case, recursive case, and reduction step are valid; infinite
      loop is not.
    text: Which of the following are valid characteristics of recursive algorithms?
    topic: Algorithm
    type: multiple
  - answer:
    - A
    - B
    - C
    choices:
      A: Expressing algorithms in plain language
      B: Planning program logic before coding
      C: Documenting code for others
      D: Compiling directly to machine code
      E: All of the above
    explanation: Pseudocode is for planning and documentation, not for direct compilation.
    text: Which of the following are valid uses of pseudocode in programming?
    topic: Algorithm
    type: multiple
  - answer:
    - A
    - B
    - C
    choices:
      A: Bubble Sort
      B: Merge Sort
      C: Quick Sort
      D: Random Sort
      E: All of the above
    explanation: Bubble, merge, and quick sort are valid; random sort is not a standard
      algorithm.
    text: Which of the following are valid types of sorting algorithms?
    topic: Algorithm
    type: multiple
- duration_minutes: 60
  id: 2
  name: Practice Set 2 - Introduction to Python, Operators, Expressions and Python
    Statements, Sequence data types (30 marks)
  questions:
  - answer: B
    choices:
      A: A snake species
      B: A high-level programming language
      C: A database system
      D: An operating system
      E: All of the above
    explanation: Python is a high-level programming language used for general-purpose
      programming.
    text: What is Python?
  - answer: A
    choices:
      A: int
      B: variable
      C: function
      D: loop
      E: All of the above
    explanation: '''int'' is a built-in data type in Python representing integers.'
    text: Which of the following is a Python data type?
  - answer: B
    choices:
      A: 2 + 3
      B: '5'
      C: '23'
      D: Error
      E: All of the above
    explanation: 2 + 3 evaluates to 5 in Python.
    text: What is the output of print(2 + 3)?
  - answer: B
    choices:
      A: ^
      B: '**'
      C: pow
      D: exp
      E: All of the above
    explanation: '''**'' is the exponentiation operator in Python.'
    text: Which operator is used for exponentiation in Python?
  - answer: B
    choices:
      A: 3.333...
      B: '3'
      C: '3.0'
      D: Error
      E: All of the above
    explanation: '''//'' is integer division; 10 // 3 gives 3.'
    text: What is the result of 10 // 3?
  - answer: B
    choices:
      A: 2name
      B: name2
      C: my-name
      D: class
      E: All of the above
    explanation: Variable names cannot start with a digit, contain hyphens, or be
      reserved keywords. 'name2' is valid.
    text: Which of the following is a valid Python variable name?
  - answer: A
    choices:
      A: HelloHelloHello
      B: Hello 3
      C: Error
      D: Hello Hello Hello
      E: All of the above
    explanation: Multiplying a string by 3 repeats it three times.
    text: What is the output of print('Hello' * 3)?
  - answer: B
    choices:
      A: Tuple
      B: List
      C: String
      D: Integer
      E: All of the above
    explanation: Lists are mutable, meaning their contents can be changed.
    text: Which data structure is mutable in Python?
  - answer: A
    choices:
      A: '4'
      B: '10'
      C: Error
      D: 1,2,3,4
      E: All of the above
    explanation: len() returns the number of elements in the list, which is 4.
    text: What is the output of len([1, 2, 3, 4])?
  - answer: B
    choices:
      A: add()
      B: append()
      C: insert()
      D: push()
      E: All of the above
    explanation: The append() method adds an element to the end of a list.
    text: Which method is used to add an element to a list?
  - answer: A
    choices:
      A: HELLO
      B: Hello
      C: hello
      D: Error
      E: All of the above
    explanation: The upper() method converts all characters to uppercase.
    text: What is the output of 'hello'.upper()?
  - answer: A
    choices:
      A: +
      B: '&'
      C: .
      D: '|'
      E: All of the above
    explanation: The '+' operator joins two strings together.
    text: Which operator is used for string concatenation?
  - answer: B
    choices:
      A: <class 'int'>
      B: <class 'float'>
      C: <class 'number'>
      D: <class 'decimal'>
      E: All of the above
    explanation: 3.14 is a floating-point number, so its type is float.
    text: What is the output of print(type(3.14))?
  - answer: A
    choices:
      A: input()
      B: get()
      C: read()
      D: scanf()
      E: All of the above
    explanation: input() reads a line from user input as a string.
    text: Which function is used to get user input in Python?
  - answer: B
    choices:
      A: 'True'
      B: 'False'
      C: '0'
      D: Error
      E: All of the above
    explanation: 0 is considered False in Python.
    text: What is the output of print(bool(0))?
  - answer: B
    choices:
      A: delete()
      B: remove()
      C: pop()
      D: clear()
      E: All of the above
    explanation: remove() deletes the first occurrence of a value from a list.
    text: Which method is used to remove an element from a list?
  - answer: B
    choices:
      A: 'True'
      B: 'False'
      C: Error
      D: '2'
      E: All of the above
    explanation: 2 is an integer and '2' is a string, so they are not equal.
    text: What is the output of print(2 == '2')?
  - answer: B
    choices:
      A: '&&'
      B: and
      C: '&'
      D: AND
      E: All of the above
    explanation: '''and'' is the logical AND operator in Python.'
    text: Which operator is used for logical AND?
  - answer: B
    choices:
      A: 'True'
      B: 'False'
      C: None
      D: Error
      E: All of the above
    explanation: not True evaluates to False.
    text: What is the output of print(not True)?
  - answer: C
    choices:
      A: List
      B: Tuple
      C: Dictionary
      D: Set
      E: All of the above
    explanation: A dictionary stores data as key-value pairs.
    text: Which data structure stores key-value pairs?
  - answer: A
    choices:
      A: '[1, 2, 3, 4, 5]'
      B: '[5, 7]'
      C: Error
      D: '[1, 2, 3][4, 5]'
      E: All of the above
    explanation: Adding two lists with '+' concatenates them.
    text: What is the output of print([1, 2, 3] + [4, 5])?
  - answer: B
    choices:
      A: find()
      B: index()
      C: search()
      D: locate()
      E: All of the above
    explanation: index() returns the position of the first occurrence of a value.
    text: Which method is used to find the index of an element in a list?
  - answer: A
    choices:
      A: 'True'
      B: 'False'
      C: Error
      D: hello
      E: All of the above
    explanation: '''in'' checks if a substring exists within a string.'
    text: What is the output of print('hello' in 'hello world')?
  - answer: A
    choices:
      A: int()
      B: str()
      C: float()
      D: convert()
      E: All of the above
    explanation: int() converts a string or number to an integer.
    text: Which function is used to convert a string to an integer?
  - answer: B
    choices:
      A: '3'
      B: '4'
      C: '3.7'
      D: Error
      E: All of the above
    explanation: round(3.7) rounds the number to the nearest integer, which is 4.
    text: What is the output of print(round(3.7))?
  - answer: A
    choices:
      A: in
      B: contains
      C: member
      D: has
      E: All of the above
    explanation: The 'in' operator checks if a value exists within a sequence, such
      as a list or string.
    text: Which operator is used for membership testing?
  - answer: B
    choices:
      A: '1'
      B: '9'
      C: '20'
      D: Error
      E: All of the above
    explanation: The max() function returns the largest value in the list, which is
      9.
    text: What is the output of print(max([1, 5, 3, 9, 2]))?
  - answer: A
    choices:
      A: sort()
      B: order()
      C: arrange()
      D: organize()
      E: All of the above
    explanation: The sort() method arranges the elements of a list in ascending order.
    text: Which method is used to sort a list in ascending order?
  - answer: A
    choices:
      A: abcabc
      B: abc 2
      C: Error
      D: abc abc
      E: All of the above
    explanation: Multiplying a string by 2 repeats the string twice, resulting in
      'abcabc'.
    text: What is the output of print('abc' * 2)?
  - answer: C
    choices:
      A: List
      B: Dictionary
      C: Tuple
      D: Set
      E: All of the above
    explanation: A tuple is an immutable data structure, meaning its contents cannot
      be changed after creation.
    text: Which data structure is immutable?
  - answer: A
    choices:
      A: '6'
      B: Python
      C: Error
      D: None
      E: All of the above
    explanation: The len() function returns the number of characters in the string
      'Python', which is 6.
    text: What is the output of print(len('Python'))?
  - answer: A
    choices:
      A: upper()
      B: uppercase()
      C: toUpper()
      D: capitalize()
      E: All of the above
    explanation: The upper() method converts all characters in a string to uppercase.
    text: Which method is used to convert a string to uppercase?
  - answer: A
    choices:
      A: '1'
      B: '8'
      C: Error
      D: None
      E: All of the above
    explanation: The min() function returns the smallest value in the list, which
      is 1.
    text: What is the output of print(min([5, 2, 8, 1]))?
  - answer: E
    choices:
      A: int
      B: float
      C: str
      D: list
      E: All of the above
    explanation: int, float, str, and list are all built-in data types in Python.
    text: Which of the following are Python data types?
    type: multiple
  - answer: E
    choices:
      A: +
      B: '-'
      C: '*'
      D: /
      E: All of the above
    explanation: +, -, *, and / are all valid arithmetic operators in Python.
    text: Which of the following are valid Python operators?
    type: multiple
  - answer:
    - A
    - B
    - D
    choices:
      A: Variable types can change at runtime
      B: Type errors can occur only at runtime
      C: You must declare variable types explicitly
      D: It allows for rapid prototyping
      E: All of the above
    explanation: Python's dynamic typing allows variable types to change and type
      errors to occur at runtime, aiding rapid prototyping.
    text: Which of the following statements about Python's dynamic typing are true
      in real-world scenarios?
    topic: Python Basics
    type: multiple
  - answer:
    - A
    - B
    - D
    choices:
      A: list1 = [1, 2, 3]
      B: list2 = list((1, 2, 3))
      C: list3 = 1, 2, 3
      D: list4 = list([1, 2, 3])
      E: All of the above
    explanation: A, B, and D are valid; C creates a tuple, not a list.
    text: Which of the following are valid ways to create a list in Python?
    topic: Data Types
    type: multiple
  - answer:
    - A
    - B
    - D
    choices:
      A: List
      B: Tuple
      C: Dictionary
      D: String
      E: All of the above
    explanation: List, tuple, and string are sequence types; dictionary is a mapping
      type.
    text: Which of the following are valid sequence data types in Python?
    topic: Sequence Data Types
    type: multiple
  - answer:
    - A
    - B
    - D
    choices:
      A: '''=='' checks value equality'
      B: '''is'' checks object identity'
      C: '''=='' and ''is'' always give the same result'
      D: '''is'' can be used to compare immutable objects'
      E: All of the above
    explanation: '''=='' checks value, ''is'' checks identity; ''is'' can compare
      immutables but may not behave as expected.'
    text: Which of the following statements about Python's '==' and 'is' operators
      are correct?
    topic: Operators & Expressions
    type: multiple
  - answer:
    - A
    - B
    - D
    choices:
      A: list1 + list2
      B: list1.extend(list2)
      C: list1.append(list2)
      D: list1 = [*list1, *list2]
      E: All of the above
    explanation: A, B, and D concatenate lists; C nests list2 inside list1.
    text: Which of the following are valid ways to concatenate two lists in Python?
    topic: Sequence Data Types
    type: multiple
  - answer: E
    choices:
      A: Check if an element exists in a list
      B: Check if a substring exists in a string
      C: Check if a key exists in a dictionary
      D: Check if a value exists in a set
      E: All of the above
    explanation: '''in'' works for membership testing in all these data structures.'
    text: Which of the following are valid uses of the 'in' operator in Python?
    topic: Operators & Expressions
    type: multiple
  - answer: E
    choices:
      A: 'd = {''a'': 1, ''b'': 2}'
      B: d = dict(a=1, b=2)
      C: d = dict([('a', 1), ('b', 2)])
      D: d = {}
      E: All of the above
    explanation: All are valid ways to create a dictionary.
    text: Which of the following are valid ways to create a dictionary in Python?
    topic: Data Types
    type: multiple
  - answer:
    - A
    - B
    - D
    choices:
      A: upper()
      B: split()
      C: append()
      D: replace()
      E: All of the above
    explanation: upper, split, and replace are string methods; append is for lists.
    text: Which of the following are valid string methods in Python?
    topic: Sequence Data Types
    type: multiple
  - answer:
    - A
    - B
    - C
    choices:
      A: 'for item in my_list: ...'
      B: 'for i in range(len(my_list)): ...'
      C: 'while my_list: ...'
      D: 'for key in my_list: ...'
      E: All of the above
    explanation: A and B are standard; C works if you pop elements; D is misleading
      unless my_list is a dict.
    text: Which of the following are valid ways to iterate over a list in Python?
    topic: Python Statements
    type: multiple
  - answer:
    - A
    - B
    - C
    choices:
      A: list2 = list1[:]
      B: list2 = list(list1)
      C: list2 = list1.copy()
      D: list2 = list1
      E: All of the above
    explanation: A, B, and C create a copy; D creates a reference.
    text: Which of the following are valid ways to copy a list in Python?
    topic: Sequence Data Types
    type: multiple
  - answer:
    - A
    - B
    choices:
      A: '''key'' in my_dict'
      B: my_dict.get('key') is not None
      C: my_dict.has_key('key')
      D: '''key'' == my_dict.keys()'
      E: All of the above
    explanation: A and B are valid; has_key is deprecated, D is incorrect.
    text: Which of the following are valid ways to check if a key exists in a dictionary?
    topic: Data Types
    type: multiple
  - answer:
    - A
    - B
    - C
    choices:
      A: strip()
      B: lstrip()
      C: rstrip()
      D: trim()
      E: All of the above
    explanation: strip, lstrip, and rstrip remove whitespace; trim does not exist.
    text: Which of the following are valid ways to remove whitespace from a string
      in Python?
    topic: Sequence Data Types
    type: multiple
  - answer:
    - A
    - B
    - C
    choices:
      A: t = (1, 2, 3)
      B: t = tuple([1, 2, 3])
      C: t = 1, 2, 3
      D: t = tuple(1, 2, 3)
      E: All of the above
    explanation: A, B, and C are valid; D is invalid syntax.
    text: Which of the following are valid ways to create a tuple in Python?
    topic: Data Types
    type: multiple
  - answer:
    - A
    - B
    - C
    choices:
      A: 'if not my_list: ...'
      B: 'if len(my_list) == 0: ...'
      C: 'if my_list == []: ...'
      D: 'if my_list is None: ...'
      E: All of the above
    explanation: A, B, and C check for emptiness; D checks for None.
    text: Which of the following are valid ways to check if a list is empty in Python?
    topic: Python Statements
    type: multiple
  - answer: E
    choices:
      A: my_list[0]
      B: my_list[-1]
      C: my_list[1:3]
      D: my_list[0:len(my_list)]
      E: All of the above
    explanation: All are valid ways to access elements or slices.
    text: Which of the following are valid ways to access elements in a list?
    topic: Sequence Data Types
    type: multiple
  - answer:
    - A
    - B
    - D
    choices:
      A: my_dict['key'] = value
      B: 'my_dict.update({''key'': value})'
      C: my_dict.set('key', value)
      D: my_dict['key'] += 1
      E: All of the above
    explanation: A and B are standard; D works if value is numeric; C is invalid.
    text: Which of the following are valid ways to update a value in a dictionary?
    topic: Data Types
    type: multiple
  - answer:
    - A
    - B
    - C
    choices:
      A: my_list.reverse()
      B: reversed(my_list)
      C: my_list[::-1]
      D: my_list = my_list.reverse()
      E: All of the above
    explanation: A, B, and C reverse a list; D assigns None.
    text: Which of the following are valid ways to reverse a list in Python?
    topic: Sequence Data Types
    type: multiple
  - answer:
    - A
    - B
    - C
    choices:
      A: str.isdigit()
      B: str.isnumeric()
      C: str.isdecimal()
      D: str.isalpha()
      E: All of the above
    explanation: A, B, and C check for numeric; D checks for alphabetic.
    text: Which of the following are valid ways to check if a string is numeric in
      Python?
    topic: Sequence Data Types
    type: multiple
  - answer:
    - A
    - B
    - C
    choices:
      A: s = {1, 2, 3}
      B: s = set([1, 2, 3])
      C: s = set((1, 2, 3))
      D: s = {}
      E: All of the above
    explanation: A, B, and C create sets; D creates a dictionary.
    text: Which of the following are valid ways to create a set in Python?
    topic: Data Types
    type: multiple
- duration_minutes: 75
  id: 3
  name: Practice Set 3 - Functions, File Processing, Modules (40 marks)
  questions:
  - answer: B
    choices:
      A: A variable
      B: A reusable block of code
      C: A data type
      D: A loop
      E: All of the above
    explanation: A function is a reusable block of code that performs a specific task.
    text: What is a function in Python?
  - answer: B
    choices:
      A: 'function my_function():'
      B: 'def my_function():'
      C: 'create my_function():'
      D: 'func my_function():'
      E: All of the above
    explanation: Functions in Python are defined using the 'def' keyword.
    text: How do you define a function in Python?
  - answer: B
    choices:
      A: To end the function
      B: To send a value back from the function
      C: To print output
      D: To create a loop
      E: All of the above
    explanation: The return statement sends a value back to the caller of the function.
    text: What is the purpose of the return statement?
  - answer: B
    choices:
      A: A parameter inside the function
      B: A value passed to the function
      C: The function name
      D: The return value
      E: All of the above
    explanation: A parameter is a value passed to a function when it is called.
    text: What is a parameter in a function?
  - answer: B
    choices:
      A: 3 + 4
      B: '7'
      C: Error
      D: None
      E: All of the above
    explanation: add(3, 4) returns 7, which is printed.
    text: 'What is the output of: def add(x, y): return x + y; print(add(3, 4))?'
  - answer: B
    choices:
      A: A required parameter
      B: A parameter with a predefined value
      C: The first parameter
      D: A return value
      E: All of the above
    explanation: A default parameter has a value if no argument is provided.
    text: What is a default parameter?
  - answer: B
    choices:
      A: Hello
      B: Hello World
      C: Error
      D: None
      E: All of the above
    explanation: The default value 'World' is used, so it prints 'Hello World'.
    text: 'What is the output of: def greet(name=''World''): return f''Hello {name}'';
      print(greet())?'
  - answer: B
    choices:
      A: A type of loop
      B: A function calling itself
      C: A data structure
      D: A variable type
      E: All of the above
    explanation: Recursion is when a function calls itself.
    text: What is recursion?
  - answer: B
    choices:
      A: The first function call
      B: The condition that stops recursion
      C: The return value
      D: The function name
      E: All of the above
    explanation: The base case is the condition that ends the recursive calls.
    text: What is a base case in recursion?
  - answer: B
    choices:
      A: '5'
      B: '120'
      C: Error
      D: None
      E: All of the above
    explanation: factorial(5) computes 5*4*3*2*1 = 120.
    text: 'What is the output of: def factorial(n): return 1 if n <= 1 else n * factorial(n-1);
      print(factorial(5))?'
  - answer: B
    choices:
      A: Creating files
      B: Reading from and writing to files
      C: Deleting files
      D: Moving files
      E: All of the above
    explanation: File processing involves reading from and writing to files.
    text: What is file processing?
  - answer: B
    choices:
      A: '''w'''
      B: '''r'''
      C: '''a'''
      D: '''x'''
      E: All of the above
    explanation: '''r'' mode opens a file for reading.'
    text: Which mode opens a file for reading?
  - answer: B
    choices:
      A: '''r'''
      B: '''w'''
      C: '''a'''
      D: '''x'''
      E: All of the above
    explanation: '''w'' mode opens a file for writing, overwriting existing content.'
    text: Which mode opens a file for writing?
  - answer: B
    choices:
      A: file = open('test.txt'); content = file.read()
      B: 'with open(''test.txt'', ''r'') as file: content = file.read()'
      C: file.read('test.txt')
      D: read('test.txt')
      E: All of the above
    explanation: The 'with' statement ensures the file is properly closed after reading.
    text: What is the correct way to open and read a file?
  - answer: B
    choices:
      A: read()
      B: readlines()
      C: readline()
      D: getlines()
      E: All of the above
    explanation: readlines() returns all lines in a file as a list.
    text: What method is used to read all lines from a file?
  - answer: B
    choices:
      A: print()
      B: write()
      C: output()
      D: save()
      E: All of the above
    explanation: The write() method writes data to a file.
    text: What method is used to write to a file?
  - answer: B
    choices:
      A: A function
      B: A file containing Python code
      C: A variable
      D: A loop
      E: All of the above
    explanation: A module is a file containing Python code that can be imported.
    text: What is a module in Python?
  - answer: B
    choices:
      A: include module_name
      B: import module_name
      C: load module_name
      D: use module_name
      E: All of the above
    explanation: Modules are imported using the 'import' statement.
    text: How do you import a module?
  - answer: B
    choices:
      A: '3'
      B: '3.141592653589793'
      C: Error
      D: None
      E: All of the above
    explanation: math.pi gives the value of pi, approximately 3.141592653589793.
    text: 'What is the output of: import math; print(math.pi)?'
  - answer: B
    choices:
      A: import function from module
      B: from module import function
      C: load function from module
      D: use function from module
      E: All of the above
    explanation: '''from module import function'' imports a specific function.'
    text: How do you import a specific function from a module?
  - answer: B
    choices:
      A: '1'
      B: A random number between 1 and 10
      C: Error
      D: '10'
      E: All of the above
    explanation: randint(1, 10) returns a random integer between 1 and 10.
    text: 'What is the output of: from random import randint; print(randint(1, 10))?'
  - answer: B
    choices:
      A: A function you create
      B: A function that comes with Python
      C: A function in a module
      D: A function that returns a value
      E: All of the above
    explanation: Built-in functions are provided by Python and available by default.
    text: What is a built-in function?
  - answer: A
    choices:
      A: '5'
      B: hello
      C: Error
      D: None
      E: All of the above
    explanation: len('hello') returns the number of characters, which is 5.
    text: 'What is the output of: print(len(''hello''))?'
  - answer: A
    choices:
      A: '123'
      B: Error
      C: None
      D: int
      E: All of the above
    explanation: str(123) converts the integer 123 to the string '123'.
    text: 'What is the output of: print(str(123))?'
  - answer: A
    choices:
      A: '456'
      B: Error
      C: None
      D: str
      E: All of the above
    explanation: int('456') converts the string '456' to the integer 456.
    text: 'What is the output of: print(int(''456''))?'
  - answer: A
    choices:
      A: '3.14'
      B: Error
      C: None
      D: str
      E: All of the above
    explanation: float('3.14') converts the string '3.14' to the float 3.14.
    text: 'What is the output of: print(float(''3.14''))?'
  - answer: A
    choices:
      A: '[''a'', ''b'', ''c'']'
      B: abc
      C: Error
      D: None
      E: All of the above
    explanation: list('abc') converts the string into a list of characters.
    text: 'What is the output of: print(list(''abc''))?'
  - answer: A
    choices:
      A: (1, 2, 3)
      B: '[1, 2, 3]'
      C: Error
      D: None
      E: All of the above
    explanation: tuple([1, 2, 3]) converts the list to a tuple.
    text: 'What is the output of: print(tuple([1, 2, 3]))?'
  - answer: A
    choices:
      A: '{''a'': 1, ''b'': 2}'
      B: '[(''a'', 1), (''b'', 2)]'
      C: Error
      D: None
      E: All of the above
    explanation: dict([('a', 1), ('b', 2)]) creates a dictionary from a list of tuples.
    text: 'What is the output of: print(dict([(''a'', 1), (''b'', 2)]))?'
  - answer: A
    choices:
      A: '{1, 2, 3}'
      B: '[1, 2, 2, 3]'
      C: Error
      D: None
      E: All of the above
    explanation: set([1, 2, 2, 3]) creates a set with unique elements.
    text: 'What is the output of: print(set([1, 2, 2, 3]))?'
  - answer: A
    choices:
      A: '5'
      B: '-5'
      C: Error
      D: None
      E: All of the above
    explanation: abs(-5) returns the absolute value, which is 5.
    text: 'What is the output of: print(abs(-5))?'
  - answer: A
    choices:
      A: '8'
      B: '6'
      C: Error
      D: None
      E: All of the above
    explanation: pow(2, 3) computes 2 to the power of 3, which is 8.
    text: 'What is the output of: print(pow(2, 3))?'
  - answer: A
    choices:
      A: '10'
      B: '4'
      C: Error
      D: None
      E: All of the above
    explanation: sum([1, 2, 3, 4]) adds all the numbers in the list.
    text: 'What is the output of: print(sum([1, 2, 3, 4]))?'
  - answer: A
    choices:
      A: '1'
      B: '8'
      C: Error
      D: None
      E: All of the above
    explanation: min([5, 2, 8, 1]) returns the smallest value, which is 1.
    text: 'What is the output of: print(min([5, 2, 8, 1]))?'
  - answer: A
    choices:
      A: '8'
      B: '1'
      C: Error
      D: None
      E: All of the above
    explanation: max([5, 2, 8, 1]) returns the largest value, which is 8.
    text: 'What is the output of: print(max([5, 2, 8, 1]))?'
  - answer: A
    choices:
      A: '[1, 1, 3, 4, 5]'
      B: '[3, 1, 4, 1, 5]'
      C: Error
      D: None
      E: All of the above
    explanation: sorted([3, 1, 4, 1, 5]) returns a sorted list.
    text: 'What is the output of: print(sorted([3, 1, 4, 1, 5]))?'
  - answer: A
    choices:
      A: <list_reverseiterator object>
      B: '[3, 2, 1]'
      C: Error
      D: None
      E: All of the above
    explanation: reversed() returns an iterator, not a list.
    text: 'What is the output of: print(reversed([1, 2, 3]))?'
  - answer: A
    choices:
      A: <enumerate object>
      B: '[(0, ''a''), (1, ''b''), (2, ''c'')]'
      C: Error
      D: None
      E: All of the above
    explanation: enumerate() returns an enumerate object, which can be converted to
      a list.
    text: 'What is the output of: print(enumerate([''a'', ''b'', ''c'']))?'
  - answer: A
    choices:
      A: <zip object>
      B: '[(1, ''a''), (2, ''b'')]'
      C: Error
      D: None
      E: All of the above
    explanation: zip() returns a zip object, which can be converted to a list.
    text: 'What is the output of: print(zip([1, 2], [''a'', ''b'']))?'
  - answer: A
    choices:
      A: To pass arguments to a program when it starts
      B: To create command line interfaces
      C: To handle user input
      D: To process files
      E: All of the above
    explanation: Command line arguments allow users to pass information to a program
      at startup.
    text: What is the purpose of command line arguments?
  - answer: A
    choices:
      A: A rule for variable scope resolution
      B: A rule for function naming
      C: A rule for module imports
      D: A rule for file handling
      E: All of the above
    explanation: LEGB stands for Local, Enclosing, Global, Built-in scopes for variable
      resolution.
    text: What is the LEGB rule in Python?
  - answer: B
    choices:
      A: A container for names
      B: A mapping from names to objects
      C: A type of variable
      D: A function scope
      E: All of the above
    explanation: A namespace is a mapping from names to objects.
    text: What is a namespace in Python?
  - answer: B
    choices:
      A: To initialize variables
      B: To mark a directory as a Python package
      C: To create functions
      D: To handle imports
      E: All of the above
    explanation: __init__.py marks a directory as a Python package.
    text: What is the purpose of the __init__.py file?
  - answer: E
    choices:
      A: print()
      B: len()
      C: type()
      D: input()
      E: All of the above
    explanation: print(), len(), type(), and input() are all built-in Python functions.
    text: Which of the following are built-in Python functions?
    type: multiple
  - answer: E
    choices:
      A: r
      B: w
      C: a
      D: x
      E: All of the above
    explanation: '''r'', ''w'', ''a'', and ''x'' are valid file modes for opening
      files in Python.'
    text: Which of the following are valid file modes in Python?
    type: multiple
  - answer:
    - A
    - B
    - C
    choices:
      A: 'def func(*args): ...'
      B: 'def func(arg1, arg2=None): ...'
      C: 'def func(**kwargs): ...'
      D: 'def func(args...): ...'
      E: All of the above
    explanation: A and C use *args and **kwargs for variable arguments; B uses a default
      argument. D is invalid syntax.
    text: Which of the following are valid ways to define a function in Python that
      takes variable numbers of arguments?
    topic: Functions
    type: multiple
  - answer: E
    choices:
      A: Return a tuple
      B: Return a list
      C: Return a dictionary
      D: Return multiple comma-separated values
      E: All of the above
    explanation: All are valid; Python allows returning tuples, lists, dicts, or multiple
      values (as a tuple).
    text: Which of the following are valid ways to return multiple values from a Python
      function?
    topic: Functions
    type: multiple
  - answer:
    - A
    - B
    - C
    choices:
      A: Calculating factorials
      B: Traversing a directory tree
      C: Implementing quicksort
      D: Infinite loops without base case
      E: All of the above
    explanation: A, B, and C are valid; D is a recursion error.
    text: Which of the following are valid uses of recursion in Python?
    topic: Recursion
    type: multiple
  - answer:
    - A
    - B
    - C
    choices:
      A: open('file.txt', 'w')
      B: open('file.txt', 'a')
      C: open('file.txt', 'x')
      D: open('file.txt', 'r')
      E: All of the above
    explanation: A, B, and C open for writing; D is for reading.
    text: Which of the following are valid ways to open a file for writing in Python?
    topic: File Processing
    type: multiple
  - answer: E
    choices:
      A: file.readlines()
      B: list(file)
      C: 'for line in file: ...'
      D: file.read()
      E: All of the above
    explanation: All are valid ways to read lines from a file.
    text: Which of the following are valid ways to read all lines from a file in Python?
    topic: File Processing
    type: multiple
  - answer: E
    choices:
      A: import math
      B: from math import sqrt
      C: import math as m
      D: from math import *
      E: All of the above
    explanation: All are valid import statements.
    text: Which of the following are valid ways to import a module in Python?
    topic: Modules & Imports
    type: multiple
  - answer:
    - A
    - B
    - C
    choices:
      A: try...except
      B: try...finally
      C: 'with open() as file: ...'
      D: 'if file.exists(): ...'
      E: All of the above
    explanation: A, B, and C are valid; D is not a standard exception handling method.
    text: Which of the following are valid ways to handle exceptions in Python file
      operations?
    topic: File Processing
    type: multiple
  - answer:
    - A
    - B
    - D
    choices:
      A: 'lambda x: x + 1'
      B: 'lambda x, y: x * y'
      C: 'def lambda(x): return x + 1'
      D: 'lambda: 42'
      E: All of the above
    explanation: A, B, and D are valid; C is invalid syntax.
    text: Which of the following are valid ways to create a lambda function in Python?
    topic: Functions
    type: multiple
  - answer: E
    choices:
      A: len([1, 2, 3])
      B: sum([1, 2, 3])
      C: max([1, 2, 3])
      D: min([1, 2, 3])
      E: All of the above
    explanation: All are valid uses of built-in functions.
    text: Which of the following are valid ways to use built-in functions in Python?
    topic: Built-in Functions
    type: multiple
  - answer: E
    choices:
      A: Positional arguments
      B: Keyword arguments
      C: '*args'
      D: '**kwargs'
      E: All of the above
    explanation: All are valid ways to pass arguments.
    text: Which of the following are valid ways to pass arguments to a function in
      Python?
    topic: Functions
    type: multiple
  - answer:
    - A
    - B
    choices:
      A: file.close()
      B: 'with open() as file: ...'
      C: os.close(file)
      D: del file
      E: All of the above
    explanation: A and B are valid; C is for file descriptors, D does not guarantee
      closing.
    text: Which of the following are valid ways to close a file in Python?
    topic: File Processing
    type: multiple
  - answer:
    - A
    - B
    - C
    choices:
      A: map(str, [1, 2, 3])
      B: 'map(lambda x: x*2, [1, 2, 3])'
      C: list(map(abs, [-1, -2, -3]))
      D: map([1, 2, 3], str)
      E: All of the above
    explanation: A, B, and C are valid; D is invalid argument order.
    text: Which of the following are valid ways to use the map() function in Python?
    topic: Built-in Functions
    type: multiple
  - answer:
    - A
    - B
    - D
    choices:
      A: 'filter(lambda x: x > 0, [1, -2, 3])'
      B: list(filter(str.isalpha, ['a', '1', 'b']))
      C: 'filter([1, 2, 3], lambda x: x > 1)'
      D: filter(None, [0, 1, 2])
      E: All of the above
    explanation: A, B, and D are valid; C is invalid argument order.
    text: Which of the following are valid ways to use the filter() function in Python?
    topic: Built-in Functions
    type: multiple
  - answer:
    - A
    - B
    - D
    choices:
      A: zip([1, 2], ['a', 'b'])
      B: list(zip([1, 2], [3, 4]))
      C: zip([1, 2, 3])
      D: zip(*[[1, 2], [3, 4]])
      E: All of the above
    explanation: A, B, and D are valid; C requires at least two iterables.
    text: Which of the following are valid ways to use the zip() function in Python?
    topic: Built-in Functions
    type: multiple
  - answer: E
    choices:
      A: enumerate(['a', 'b', 'c'])
      B: list(enumerate(['a', 'b', 'c']))
      C: enumerate(['a', 'b', 'c'], 1)
      D: enumerate(['a', 'b', 'c'], start=1)
      E: All of the above
    explanation: All are valid uses of enumerate.
    text: Which of the following are valid ways to use the enumerate() function in
      Python?
    topic: Built-in Functions
    type: multiple
  - answer:
    - A
    - B
    - C
    choices:
      A: sorted([3, 1, 2])
      B: sorted([3, 1, 2], reverse=True)
      C: 'sorted([3, 1, 2], key=lambda x: -x)'
      D: 'sorted([3, 1, 2], cmp=lambda x, y: x-y)'
      E: All of the above
    explanation: A, B, and C are valid; D is not supported in Python 3.
    text: Which of the following are valid ways to use the sorted() function in Python?
    topic: Built-in Functions
    type: multiple
  - answer: E
    choices:
      A: os.remove('file.txt')
      B: os.rename('old.txt', 'new.txt')
      C: os.path.exists('file.txt')
      D: os.mkdir('folder')
      E: All of the above
    explanation: All are valid uses of the os module for file and directory operations.
    text: Which of the following are valid ways to use the os module for file operations
      in Python?
    topic: File Processing
    type: multiple
  - answer: E
    choices:
      A: sys.argv
      B: sys.exit()
      C: sys.path
      D: sys.stdin
      E: All of the above
    explanation: All are valid uses of the sys module.
    text: Which of the following are valid ways to use the sys module in Python?
    topic: Modules & Imports
    type: multiple
- duration_minutes: 25
  id: 4
  name: Practice Set 4 - NumPy Basics (10 marks)
  questions:
  - answer: B
    choices:
      A: A programming language
      B: A library for numerical computing in Python
      C: A database system
      D: An operating system
      E: All of the above
    explanation: NumPy is a Python library for numerical and scientific computing.
    text: What is NumPy?
  - answer: D
    choices:
      A: import numpy
      B: import numpy as np
      C: from numpy import *
      D: All of the above
      E: All of the above
    explanation: All these statements are valid ways to import NumPy.
    text: How do you import NumPy?
  - answer: B
    choices:
      A: A normal Python list
      B: A multi-dimensional array object
      C: A function
      D: A variable
      E: All of the above
    explanation: An ndarray is a multi-dimensional array object in NumPy.
    text: What is an ndarray?
  - answer: D
    choices:
      A: array([1, 2, 3])
      B: np.array([1, 2, 3])
      C: numpy.array([1, 2, 3])
      D: All of the above
      E: All of the above
    explanation: All these methods can create a NumPy array from a list.
    text: How do you create a NumPy array from a list?
  - answer: A
    choices:
      A: (3,)
      B: (1, 3)
      C: '3'
      D: Error
      E: All of the above
    explanation: arr.shape returns the dimensions of the array; (3,) means a 1D array
      with 3 elements.
    text: 'What is the output of: import numpy as np; arr = np.array([1, 2, 3]); print(arr.shape)?'
  - answer: A
    choices:
      A: int64
      B: int32
      C: integer
      D: number
      E: All of the above
    explanation: arr.dtype shows the data type of the array elements, commonly int64.
    text: 'What is the output of: import numpy as np; arr = np.array([1, 2, 3]); print(arr.dtype)?'
  - answer: B
    choices:
      A: np.array([1, 2, 3, 4])
      B: np.array([[1, 2], [3, 4]])
      C: np.array(2, 2)
      D: np.2darray([1, 2, 3, 4])
      E: All of the above
    explanation: A 2D array is created by passing a list of lists to np.array().
    text: How do you create a 2D array in NumPy?
  - answer: A
    choices:
      A: '[0 0 0]'
      B: '[0, 0, 0]'
      C: '0'
      D: Error
      E: All of the above
    explanation: np.zeros(3) creates an array of three zeros.
    text: 'What is the output of: import numpy as np; arr = np.zeros(3); print(arr)?'
  - answer: A
    choices:
      A: '[[1. 1.] [1. 1.]]'
      B: '[1, 1, 1, 1]'
      C: '1'
      D: Error
      E: All of the above
    explanation: np.ones((2, 2)) creates a 2x2 array filled with 1.0.
    text: 'What is the output of: import numpy as np; arr = np.ones((2, 2)); print(arr)?'
  - answer: A
    choices:
      A: '[0 1 2 3 4]'
      B: '[1 2 3 4 5]'
      C: '[0, 1, 2, 3, 4]'
      D: Error
      E: All of the above
    explanation: np.arange(5) creates an array with values from 0 to 4.
    text: 'What is the output of: import numpy as np; arr = np.arange(5); print(arr)?'
  - answer: E
    choices:
      A: np.array([1, 2, 3])
      B: numpy.array([1, 2, 3])
      C: array([1, 2, 3])
      D: All of the above
      E: All of the above
    explanation: All these are valid ways to create a NumPy array from data.
    text: Which of the following are valid ways to create a NumPy array?
    type: multiple
  - answer: E
    choices:
      A: np.zeros()
      B: np.ones()
      C: np.arange()
      D: np.linspace()
      E: All of the above
    explanation: All these functions are used in NumPy to create arrays with different
      initial values or ranges.
    text: Which of the following are NumPy functions for creating arrays?
    type: multiple
  - answer:
    - Exponentiation
    - Integer Division
    - Modulus (remainder)
    - Not equal to
    choices:
    - left: '**'
      right: Exponentiation
    - left: //
      right: Integer Division
    - left: '%'
      right: Modulus (remainder)
    - left: '!='
      right: Not equal to
    explanation: '** is for exponentiation, // for integer division, % for modulus,
      and != for not equal to.'
    text: Match the following Python operators with their description.
    topic: Operators, Expressions and Python Statements
    type: match
  - answer:
    - Mutable sequence of elements
    - Immutable sequence of elements
    - Mutable collection of key-value pairs
    - Unordered collection of unique elements
    choices:
    - left: List
      right: Mutable sequence of elements
    - left: Tuple
      right: Immutable sequence of elements
    - left: Dictionary
      right: Mutable collection of key-value pairs
    - left: Set
      right: Unordered collection of unique elements
    explanation: Lists are mutable sequences, Tuples are immutable sequences, Dictionaries
      are key-value mappings, and Sets contain unique unordered items.
    text: Match the following Python data types with their key characteristic.
    topic: Sequence data types
    type: match
  - answer: C
    choices:
      A: |
        import numpy as np  
        nums = np.array[10, 20, 30]  
        print nums  
      B: |
        import numpy  
        nums = numpy.array([10, 20, 30])  
        print(nums)  
      C: |
        import numpy as np  
        nums = np.array([10, 20, 30])  
        print(nums)  
      D: |
        import np  
        nums = np.array(10, 20, 30)  
        print(nums)  
    explanation: Option C uses the correct alias, array creation, and print syntax.
    text: What is the correct way to import NumPy with an alias and create a 1-dimensional array named `nums` with the values `[10, 20, 30]` and print it, considering the correct Python syntax and conventions?
  - answer: D
    choices:
      A: NumPy only supports one-dimensional arrays, and shape is irrelevant.
      B: Axes are named like rows and columns, and the shape is not important.
      C: NumPy arrays are identified by the number of axes, where shape is a tuple representing size along each axis starting from axis 1.
      D: NumPy arrays are identified by the number of axes (dimensions), and shape is a tuple indicating the size along each axis starting from axis 0.
    explanation: NumPy arrays are defined by their number of axes (dimensions), and shape is a tuple of sizes along each axis starting from 0.
    text: Which of the following best describes how NumPy treats the shape and dimensionality of arrays?
  - answer: C
    choices:
      A: 30 and throws error
      B: 25 and 30
      C: 30 and 30
      D: 15 and 30
    explanation: Both nums[1][2] and nums[1,2] access the same element, which is 30.
    text: "Given the following array definition:\n\n```python\nimport numpy as np  \nnums = np.array([[5, 10, 15], [20, 25, 30]])  \n```\n\nWhat will `nums[1][2]` and `nums[1,2]` output respectively?"
  - answer: A
    choices:
      A: NumPy arrays can contain heterogeneous data types.
      B: NumPy arrays provide faster computations than Python lists.
      C: NumPy arrays support operations over entire arrays without using loops.
      D: NumPy arrays are stored in contiguous blocks of memory.
    explanation: NumPy arrays are homogeneous; they cannot contain heterogeneous data types.
    text: Which of the following statements is **false** regarding NumPy arrays?
  - answer: A
    choices:
      A: (3, 3) and 8
      B: (3, 3) and 7
      C: (9,) and 8
      D: (3,) and 2
    explanation: arr.shape is (3, 3) and arr[2, 1] is 8.
    text: "Consider the following NumPy array:\n\n```python\narr = np.array([[1,2,3], [4,5,6], [7,8,9]])  \n```\n\nWhat will `arr.shape` and `arr[2, 1]` return?"
  - answer: D
    choices:
      A: It will raise a SyntaxError.
      B: It will flatten the list to a 1D array.
      C: It will raise a ValueError.
      D: It will create an array of type object with inconsistent inner dimensions.
    explanation: NumPy will create an array of dtype object if the inner lists are of unequal length.
    text: What will happen if you pass a list of unequal lengths to `np.array()`?
  - answer: C
    choices:
      A: NumPy is newer and simpler.
      B: NumPy supports graphical user interfaces.
      C: NumPy arrays support broadcasting, vectorization, and better memory efficiency.
      D: Python lists are not compatible with scikit-learn.
    explanation: NumPy is preferred for ML because of broadcasting, vectorization, and memory efficiency.
    text: Which of the following best explains why NumPy is preferred for Machine Learning over Python lists?
  - answer: C
    choices:
      A: Operations are not possible directly on NumPy arrays.
      B: Operations apply only if you use loops manually.
      C: Operations are broadcasted automatically if dimensions align.
      D: NumPy throws an error unless you use np.vectorize.
    explanation: NumPy automatically broadcasts element-wise operations if dimensions align.
    text: How does NumPy handle element-wise operations like addition or multiplication on arrays?
  - answer: A
    choices:
      A: "5"
      B: "6"
      C: "7"
      D: "4"
    explanation: arr[0][1] is 2, arr[1,0] is 3, so 2+3=5.
    text: "What will the following code output?\n\n```python\nimport numpy as np  \narr = np.array([[1, 2], [3, 4]])  \nprint(arr[0][1] + arr[1,0])  \n```"
  - answer: B
    choices:
      A: |
        nums = np.array([1, 2, 3, 4], [11, 12, 13, 14])
        print(nums[2])
      B: |
        nums = np.array([[1, 2, 3, 4], [11, 12, 13, 14]])
        print(nums[1][2])
      C: |
        nums = np.array([[1, 2], [11, 12, 13, 14]])
        print(nums[1][2])
      D: |
        nums = np.array([[1, 2, 3], [11, 12, 13, 14]])
        print(nums[1,3])
    explanation: Option B correctly creates a 2D array and accesses the value 13.
    text: Which of the following correctly defines a 2-D array and accesses the value `13` from it?
  - answer: B
    choices:
      A: "Axis 0: columns, Axis 1: rows, Axis 2: pages"
      B: "Axis 0: 2 blocks, Axis 1: 3 rows per block, Axis 2: 4 columns per row"
      C: "Axis 0: 4 columns, Axis 1: 3 rows, Axis 2: 2 slices"
      D: "Axis 0: 3 slices, Axis 1: 2 rows, Axis 2: 4 columns"
    explanation: For shape (2, 3, 4), axis 0 is blocks, axis 1 is rows, axis 2 is columns.
    text: How do you define the axis in NumPy for a 3-D array `arr.shape = (2, 3, 4)`?
  - answer: D
    choices:
      A: np.array([2,4,6,8,10])
      B: np.arange(2,10)
      C: np.arange(2,11,2)
      D: Both A and C
    explanation: Both A and C create a 1D array of even numbers from 2 to 10 inclusive.
    text: Which line would create a one-dimensional NumPy array containing even numbers between 2 and 10 (inclusive)?
  - answer: B
    choices:
      A: It creates a deep copy of the NumPy module.
      B: It renames the module within the script to simplify function calls.
      C: It removes unnecessary functions from NumPy.
      D: It imports only array-related functions from NumPy.
    explanation: The 'as' keyword allows you to use a shorter alias for the module.
    text: What is the role of `as` in `import numpy as np`?
  - answer: A
    choices:
      A: Broadcasting
      B: Loop Fusion
      C: Compression
      D: Allocation
    explanation: Broadcasting allows operations on entire arrays without explicit loops.
    text: Which NumPy feature allows the execution of operations on entire arrays without writing explicit loops?
  - answer: A
    choices:
      A: "Shape: (3, 2), Axes: 0 (rows), 1 (columns)"
      B: "Shape: (2, 3), Axes: 1 (rows), 0 (columns)"
      C: "Shape: [3,2], Axes: 0 (elements), 1 (none)"
      D: "Shape: 6, Axes: 2"
    explanation: The array has shape (3,2) and axes 0 (rows), 1 (columns).
    text: Which of the following is a valid representation of shape and axes for the array `np.array([[1,2], [3,4], [5,6]])`?
  - answer: A
    choices:
      A: Both are valid and yield the same result.
      B: Only arr[i,j] is valid for 2-D arrays.
      C: Only arr[i][j] works in older NumPy versions.
      D: It depends on the data type of the array.
    explanation: Both arr[i][j] and arr[i,j] are valid and yield the same result for 2D arrays.
    text: What happens when you access a NumPy 2-D array using both `arr[i][j]` and `arr[i,j]`?
  - answer: B
    choices:
      A: Fast computation with vectorized operations
      B: In-memory database management
      C: Integration with ML libraries like Scikit-learn
      D: Efficient multidimensional array handling
    explanation: In-memory database management is not a core advantage of NumPy.
    text: Which is **not** a core advantage of using NumPy in data science and machine learning?
  - answer: B
    choices:
      A: "[2]"
      B: "[2, 5]"
      C: "[1, 4]"
      D: "[1, 2]"
    explanation: nums[0:2, 1] selects the second column from both rows, giving [2, 5].
    text: Given `nums = np.array([[1, 2, 3], [4, 5, 6]])`, what will `nums[0:2, 1]` return?
  - answer: B
    choices:
      A: All arrays must be of same shape
      B: Elements in an array must be of the same data type
      C: Arrays must be one-dimensional
      D: Arrays can only contain integers
    explanation: Homogeneous means all elements are of the same data type.
    text: What does the term "homogeneous" imply in the context of NumPy arrays?
  - answer: D
    choices:
      A: NumPy does not support 2D arrays.
      B: The second list must be nested inside the first.
      C: The syntax is invalid; tuples should be inside another list.
      D: The second argument is not passed as a list of lists for 2D structure.
    explanation: The second argument is not a list of lists, so NumPy cannot interpret it as a 2D array.
    text: "Why might this NumPy command raise an error?\n\n```python\nnums = np.array([1, 2, 3], (4, 5, 6))  \n```"
  - answer: A
    choices:
      A: "[3, 5] — because it slices from row 1 onwards and picks column 0"
      B: "[1, 3, 5] — because it picks every alternate row"
      C: "[2, 4, 6] — because it accesses the second column"
      D: "Error — incorrect slicing syntax for a 2D array"
    explanation: arr[1:, 0] slices from row 1 onward (i.e., rows 1 and 2) and picks column 0, so it returns [3, 5].
    text: "What will the output be for the following code and why?\n\n```python\nimport numpy as np  \narr = np.array([[1, 2], [3, 4], [5, 6]])  \nprint(arr[1:, 0])  \n```"
  - answer: C
    choices:
      A: NumPy arrays use object references for each element
      B: NumPy uses hash tables to store data
      C: NumPy uses contiguous memory blocks and vectorized operations
      D: NumPy duplicates memory space for faster access
    explanation: NumPy uses contiguous memory and vectorized operations for performance.
    text: Which of the following best explains how NumPy enhances performance compared to Python's built-in lists?
  - answer: D
    choices:
      A: Prints [[10, 2], [3, 4]] because b is a deep copy of a
      B: Prints [[1, 2], [3, 4]] because b is independent of a
      C: Raises an error due to assignment
      D: Prints [[10, 2], [3, 4]] because b is a reference to a
    explanation: b is a reference to a, so changes to b affect a.
    text: "What does the following code do?\n\n```python\na = np.array([[1, 2], [3, 4]])  \nb = a  \nb[0][0] = 10  \nprint(a)  \n```"
  - answer: C
    choices:
      A: A list with 2 zeros repeated 3 times
      B: "A 2x3 matrix of None values"
      C: "A 2x3 array filled with zeros of type float64"
      D: "A 3x2 array of integers set to zero"
    explanation: np.zeros((2,3)) creates a 2x3 array of zeros (float64 by default).
    text: What does `np.zeros((2,3))` create?
  - answer: D
    choices:
      A: a[1]
      B: a[1,:]
      C: a[1,0:3]
      D: All of the above
    explanation: All these expressions return the second row of the array.
    text: "Which of the following slicing operations will return the **second row** of this array:\n\n```python\na = np.array([[10, 20, 30], [40, 50, 60], [70, 80, 90]])  \n```"
  - answer: B
    choices:
      A: "[1, 2, 3, 4, 5] — reversed internally but prints same"
      B: "[5, 4, 3, 2, 1] — reversed array"
      C: "[1, 3, 5] — skips alternate items"
      D: "Error — step value cannot be negative"
    explanation: x[::-1] reverses the array.
    text: If x = np.array([1, 2, 3, 4, 5]), what will x[::-1] return?
  - answer: C
    choices:
      A: Copying arrays to a server
      B: A way of storing large arrays efficiently
      C: Automatic expansion of dimensions during arithmetic operations
      D: Conversion of scalars to arrays
    explanation: Broadcasting is automatic expansion of dimensions during arithmetic operations.
    text: What is broadcasting in NumPy?
  - answer: D
    choices:
      A: np.array([[1,0,0],[0,1,0],[0,0,1]])
      B: np.identity(3)
      C: np.eye(3)
      D: All of the above
    explanation: All these create a 3x3 identity matrix in NumPy.
    text: Which of the following expressions would create a 3×3 identity matrix in NumPy?
  - answer: B
    choices:
      A: Uses shared pointers
      B: Stores type metadata once per array
      C: Uses GPU RAM by default
      D: Makes multiple copies to avoid corruption
    explanation: NumPy stores type metadata once per array, making memory usage efficient.
    text: How does NumPy handle memory usage more efficiently than regular Python lists?
  - answer: A
    choices:
      A: (2,3) 2 6
      B: (2,3) 3 6
      C: (3,2) 2 5
      D: (2,3) 2 5
    explanation: arr.shape is (2,3), arr.ndim is 2, arr.size is 6.
    text: "Consider the code:\n\n```python\narr = np.array([[10,20,30],[40,50,60]])  \nprint(arr.shape, arr.ndim, arr.size)  \n```\n\nWhat is the output?"
  - answer: B
    choices:
      A: Both are 1-D arrays
      B: First is 1-D, second is 2-D
      C: Both are 2-D arrays
      D: First is 2-D, second is 3-D
    explanation: np.array([1,2,3]) is 1D, np.array([[1,2,3]]) is 2D.
    text: Which of the following best explains the difference between `np.array([1,2,3])` and `np.array([[1,2,3]])`?
  - answer: A
    choices:
      A: int64 or int32 depending on system architecture
      B: float64
      C: object
      D: str
    explanation: The default dtype is int64 or int32 depending on the system.
    text: What is the default data type when you create an array using `np.array([1, 2, 3])`?
  - answer: B
    choices:
      A: arr[>10]
      B: arr[arr>10]
      C: arr(arr>10)
      D: "filter(arr, lambda x: x > 10)"
    explanation: arr[arr>10] returns all elements greater than 10.
    text: How would you extract all elements from a 2D array arr that are greater than 10?
  - answer: C
    choices:
      A: Same array
      B: 1D flattened version
      C: Transposed version of the array
      D: Error — .T is not a method
    explanation: arr.T returns the transpose of the array.
    text: Given arr = np.array([[1,2],[3,4]]), what will arr.T return?
  - answer: C
    choices:
      A: Create an array from 1 to 10 (step 2) and reshape to 3 rows, 2 columns
      B: Create a 3D array
      C: Error — cannot reshape 5 elements to shape (3,2)
      D: Returns [1, 3], [5, 7], [9, 10]
    explanation: np.arange(1, 10, 2) creates 5 elements, which cannot be reshaped to (3,2).
    text: What will np.arange(1, 10, 2).reshape((3, 2)) do?
  - answer: A
    choices:
      A: "[20, 30, 40]"
      B: "[10, 20, 30]"
      C: "[30, 40, 50]"
      D: "[20, 30, 40, 50]"
    explanation: arr[1:4] returns elements at indices 1, 2, and 3.
    text: "What is the result of the following array slicing?\n\n```python\narr = np.array([10, 20, 30, 40, 50])  \nprint(arr[1:4])  \n```"
  - answer: D
    choices:
      A: arr.squeeze()
      B: arr.flatten()
      C: arr.reshape(-1)
      D: Both B and C
    explanation: arr.flatten() and arr.reshape(-1) both return a flattened 1D array.
    text: In NumPy, which method will return a flattened 1D version of any N-dimensional array?
  - answer: C
    choices:
      A: np.constant(3, value=7)
      B: np.fill((3,3), 7)
      C: np.full((3,3), 7)
      D: np.ones((3,3))*7
    explanation: np.full((3,3), 7) creates a 3x3 array filled with 7s.
    text: "Which NumPy method is used to create arrays filled with a constant value (e.g., all 7s in a 3x3 matrix)?"
  - answer: C
    choices:
      A: np.append(a, b)
      B: np.hstack((a, b))
      C: np.vstack((a, b))
      D: np.stack((a, b), axis=1)
    explanation: np.vstack stacks arrays vertically (row-wise).
    text: Which of the following methods is used to stack two NumPy arrays vertically?
  - answer: B
    choices:
      A: From row 1 onward, all columns
      B: From row 1 onward, all columns except last
      C: From first row onward, only last column
      D: Error in slicing format
    explanation: arr[1:, :-1] means from row 1 onward, all columns except the last.
    text: "How does NumPy interpret this indexing operation: arr[1: , :-1]?"
